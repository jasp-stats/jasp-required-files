<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: p-values for fixed effects of mixed-model via lme4::lmer()</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mixed {afex}"><tr><td>mixed {afex}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>p-values for fixed effects of mixed-model via lme4::lmer()</h2>

<h3>Description</h3>

<p>Estimates mixed models with <span class="pkg">lme4</span> and calculates p-values
for all fixed effects. The default method <code>"KR"</code> (= Kenward-Roger) as
well as  <code>method="S"</code> (Satterthwaite) support LMMs and estimate the
model with <code><a href="../../lmerTest/html/lmer.html">lmer</a></code> and then pass it to the
<code><a href="../../lmerTest/html/lmerTest.html">lmerTest</a></code> <code>anova</code> method (or
<code><a href="../../car/html/Anova.html">Anova</a></code>). The other methods (<code>"LRT"</code> =
likelihood-ratio tests and <code>"PB"</code> = parametric bootstrap) support both
LMMs (estimated via <code><a href="../../lme4/html/lmer.html">lmer</a></code>) and GLMMs (i.e., with
<code>family</code> argument which invokes estimation via
<code><a href="../../lme4/html/glmer.html">glmer</a></code>) and estimate a full model and restricted models
in which the parameters corresponding to one effect (i.e., model term) are
withhold (i.e., fixed to 0). Per default tests are based on Type 3 sums of
squares. <code>print</code>, <code>nice</code>, <code>anova</code>, and <code>summary</code>
methods for the returned object of class <code>"mixed"</code> are available.
<code>summary</code> invokes the default <span class="pkg">lme4</span> summary method and shows
parameters instead of effects.
</p>
<p><code>lmer_alt</code> is simply a wrapper for mixed that only returns the
<code>"lmerModLmerTest"</code> or <code>"merMod"</code> object and correctly uses the
<code>||</code> notation for removing correlations among factors. This function
otherwise behaves like <code>g/lmer</code> (as for <code>mixed</code>, it calls
<code>glmer</code> as soon as a <code>family</code> argument is present). Use
<code><a href="afex_options.html">afex_options</a></code><code>("lmer_function")</code> to set which function
for estimation should be used. This option determines the class of the
returned object (i.e., <code>"lmerModLmerTest"</code> or <code>"merMod"</code>).
</p>


<h3>Usage</h3>

<pre>
mixed(
  formula,
  data,
  type = afex_options("type"),
  method = afex_options("method_mixed"),
  per_parameter = NULL,
  args_test = list(),
  test_intercept = FALSE,
  check_contrasts = afex_options("check_contrasts"),
  expand_re = FALSE,
  all_fit = FALSE,
  set_data_arg = afex_options("set_data_arg"),
  progress = TRUE,
  cl = NULL,
  return = "mixed",
  sig_symbols = afex_options("sig_symbols"),
  ...
)

lmer_alt(formula, data, check_contrasts = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>
<p>a formula describing the full mixed-model to be fitted. As
this formula is passed to <code>lmer</code>, it needs at least one random term.</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p><code>data.frame</code> containing the data. Should have all the
variables present in <code>fixed</code>, <code>random</code>, and <code>dv</code> as columns.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>type of test on which effects are based. Default is to use type 3
tests, taken from <code><a href="afex_options.html">afex_options</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>character vector indicating which methods for obtaining
p-values should be used: <code>"KR"</code> corresponds to the Kenward-Roger
approximation for degrees of freedom (only LMMs), <code>"S"</code> corresponds to
the Satterthwaite approximation for degrees of freedom (via
<code><a href="../../lmerTest/html/lmerTest-package.html">lmerTest</a></code>, only LMMs), <code>"PB"</code> calculates p-values based
on parametric bootstrap, <code>"LRT"</code> calculates p-values via the
likelihood ratio tests implemented in the <code>anova</code> method for
<code>merMod</code> objects (only recommended for models with many [i.e., &gt; 50]
levels for the random factors). The default (currently <code>"KR"</code>) is
taken from <code><a href="afex_options.html">afex_options</a></code>. For historical compatibility
<code>"nested-KR"</code> is also supported which was the default KR-method in
previous versions.</p>
</td></tr>
<tr valign="top"><td><code>per_parameter</code></td>
<td>
<p><code>character</code> vector specifying for which variable
tests should be run for each parameter (instead for the overall effect).
Can be useful e.g., for testing ordered factors. Uses <code><a href="../../base/html/grep.html">grep</a></code>
for selecting parameters among the fixed effects so regular expressions
(<code><a href="../../base/html/regex.html">regex</a></code>) are possible. See Examples.</p>
</td></tr>
<tr valign="top"><td><code>args_test</code></td>
<td>
<p><code>list</code> of arguments passed to the function calculating
the p-values. See Details.</p>
</td></tr>
<tr valign="top"><td><code>test_intercept</code></td>
<td>
<p>logical. Whether or not the intercept should also be
fitted and tested for significance. Default is <code>FALSE</code>. Only relevant
if <code>type = 3</code>.</p>
</td></tr>
<tr valign="top"><td><code>check_contrasts</code></td>
<td>
<p><code>logical</code>. Should contrasts be checked and (if
necessary) changed to <code>"contr.sum"</code>? See Details. The default
(<code>"TRUE"</code>) is taken from <code><a href="afex_options.html">afex_options</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>expand_re</code></td>
<td>
<p>logical. Should random effects terms be expanded (i.e.,
factors transformed into numerical variables) before fitting with
<code>(g)lmer</code>? Allows to use &quot;||&quot; notation with factors.</p>
</td></tr>
<tr valign="top"><td><code>all_fit</code></td>
<td>
<p>logical. Should <code><a href="all_fit.html">all_fit</a></code> be used to fit each
model with each available optimization algorithm and the results that
provided the best fit in each case be used? Warning: This can dramatically
increase the optimization time. Adds two new attributes to the returned
object designating which algorithm was selected and the log-likelihoods for
each algorithm. Note that only warnings from the initial fit are emitted
during fitting. The warnings of the chosen models are emitted when printing
the returned object.</p>
</td></tr>
<tr valign="top"><td><code>set_data_arg</code></td>
<td>
<p><code>logical</code>. Should the data argument in the slot
<code>call</code> of the <code>merMod</code> object returned from <code>lmer</code> be set to
the passed data argument? If <code>FALSE</code> (currently the default) the name
will be <code>data</code>. <code>TRUE</code> may be helpful when fitted objects are
used afterwards (e.g., compared using <code>anova</code> or when using the
<code>effects</code> package, see examples). <span class="pkg">emmeans</span> functions appear to
work better with <code>FALSE</code>. Default is given by
afex_options(&quot;set_data_arg&quot;).</p>
</td></tr>
<tr valign="top"><td><code>progress</code></td>
<td>
<p>if <code>TRUE</code>, shows progress with a text progress bar and
other status messages during estimation</p>
</td></tr>
<tr valign="top"><td><code>cl</code></td>
<td>
<p>A vector identifying a cluster; used for distributing the
estimation of the different models using several cores (if seveal models
are calculated). See examples. If <code>ckeck_contrasts = TRUE</code>, mixed sets
the current contrasts (<code>getOption("contrasts")</code>) at the nodes. Note
this does <em>not</em> distribute calculation of p-values (e.g., when using
<code>method = "PB"</code>) across the cluster. Use <code>args_test</code> for this.</p>
</td></tr>
<tr valign="top"><td><code>return</code></td>
<td>
<p>the default is to return an object of class <code>"mixed"</code>.
<code>return = "merMod"</code> will skip the calculation of all submodels and
p-values and simply return the full model estimated with <code>lmer</code> (note
that somewhat unintuiviely, the returned object can either be of class
<code>"lmerModLmerTest"</code> or of class <code>"merMod"</code>, depending on the
value of <code><a href="afex_options.html">afex_options</a></code><code>("lmer_function")</code>). Can be useful
in combination with <code>expand_re = TRUE</code> which allows to use &quot;||&quot; with
factors. <code>return = "data"</code> will not fit any models but just return the
data that would have been used for estimating the model (note that the data
is also part of the returned object).</p>
</td></tr>
<tr valign="top"><td><code>sig_symbols</code></td>
<td>
<p>Character. What should be the symbols designating
significance? When entering an vector with <code>length(sig.symbol) &lt; 4</code>
only those elements of the default (<code>c(" +", " *", " **", " ***")</code>)
will be replaced. <code>sig_symbols = ""</code> will display the stars but not
the <code>+</code>, <code>sig_symbols = rep("", 4)</code> will display no symbols. The
default is given by <code>afex_options("sig_symbols")</code>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>further arguments (such as <code>weights</code>, <code>family</code>, or
<code>control</code>) passed to <code><a href="reexports.html">lmer</a></code>/<code><a href="../../lme4/html/glmer.html">glmer</a></code>. Note that
additional data (e.g., <code>weights</code>) need to be passed fully and not only
by name (e.g., <code>weights = df$weights</code> and not <code>weights =
weights</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an introduction to mixed-modeling for experimental designs see
our chapter
(<a href="http://singmann.org/download/publications/singmann_kellen-introduction-mixed-models.pdf">Singmann
&amp; Kellen, in press</a>) or Barr, Levy, Scheepers, &amp; Tily (2013). Arguments for
using the Kenward-Roger approximation for obtaining p-values are given by
Judd, Westfall, and Kenny (2012). Further introductions to mixed-modeling
for experimental designs are given by Baayen and colleagues (Baayen, 2008;
Baayen, Davidson &amp; Bates, 2008; Baayen &amp; Milin, 2010). Specific
recommendations on which random effects structure to specify for
confirmatory tests can be found in Barr and colleagues (2013) and Barr
(2013), but also see Bates et al. (2015).
</p>


<h4>p-value Calculations</h4>

<p>When <code>method = "KR"</code> (the default, implemented via
<code><a href="../../pbkrtest/html/KRmodcomp.html">KRmodcomp</a></code>), the Kenward-Roger approximation for
degrees-of-freedom is calculated using <code><a href="../../lmerTest/html/lmerTest.html">lmerTest</a></code> (if
<code>test_intercept=FALSE</code>) or <code><a href="../../car/html/Anova.html">Anova</a></code> (if
<code>test_intercept=TRUE</code>), which is only applicable to linear-mixed models
(LMMs). The test statistic in the output is an F-value (<code>F</code>). A similar
method that requires less RAM is <code>method = "S"</code> which calculates the
Satterthwaite approximation for degrees-of-freedom via
<code><a href="../../lmerTest/html/lmerTest.html">lmerTest</a></code> and is also only applicable to LMMs.
<code>method = "KR"</code> or <code>method = "S"</code> provide the best control for
Type 1 errors for LMMs (Luke, 2017).
</p>
<p><code>method = "PB"</code> calculates p-values using parametric bootstrap using
<code><a href="../../pbkrtest/html/PBmodcomp.html">PBmodcomp</a></code>. This can be used for linear and also
generalized linear mixed models (GLMMs) by specifying a
<code><a href="../../stats/html/family.html">family</a></code> argument to <code>mixed</code>. Note that you should
specify further arguments to <code>PBmodcomp</code> via <code>args_test</code>,
especially <code>nsim</code> (the number of simulations to form the reference
distribution) or <code>cl</code> (for using multiple cores). For other arguments
see <code><a href="../../pbkrtest/html/PBmodcomp.html">PBmodcomp</a></code>. Note that <code>REML</code> (argument to
<code>[g]lmer</code>) will be set to <code>FALSE</code> if method is <code>PB</code>.
</p>
<p><code>method = "LRT"</code> calculates p-values via likelihood ratio tests
implemented in the <code>anova</code> method for <code>"merMod"</code> objects. This is
the method recommended by Barr et al. (2013; which did not test the other
methods implemented here). Using likelihood ratio tests is only recommended
for models with many levels for the random effects (&gt; 50), but can be pretty
helpful in case the other methods fail (due to memory and/or time
limitations). The
<a href="http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html">lme4 faq</a> also
recommends the other methods over likelihood ratio tests. </p>



<h4>Implementation Details</h4>

<p>For methods <code>"KR"</code> and <code>"S"</code> type 3 and 2 tests are implemented as
in <code><a href="../../car/html/Anova.html">Anova</a></code>.
</p>
<p>For all other methods, type 3 tests are obtained by comparing a model in
which only the tested effect is excluded with the full model (containing all
effects). For method <code>"nested-KR"</code> (which was the default in previous
versions) this corresponds to the (type 3) Wald tests given by
<code>car::Anova</code> for <code>"lmerMod"</code> models. The submodels in which the
tested effect is excluded are obtained by manually creating a model matrix
which is then fitted in <code>"lme4"</code>.
</p>
<p>Type 2 tests are truly sequential. They are obtained by comparing a model in
which the tested effect and all higher oder effect (e.g., all three-way
interactions for testing a two-way interaction) are excluded with a model in
which only effects up to the order of the tested effect are present and all
higher order effects absent. In other words, there are multiple full models,
one for each order of effects. Consequently, the results for lower order
effects are identical of whether or not higher order effects are part of the
model or not. This latter feature is not consistent with classical ANOVA
type 2 tests but a consequence of the sequential tests (and
<a href="https://stat.ethz.ch/pipermail/r-sig-mixed-models/2012q3/018992.html">I
didn't find a better way</a> of implementing the Type 2 tests). This
<strong>does not</strong> correspond to the (type 2) Wald test reported by
<code>car::Anova</code>.
</p>
<p>If <code>check_contrasts = TRUE</code>, contrasts will be set to
<code>"contr.sum"</code> for all factors in the formula if default contrasts are
not equal to <code>"contr.sum"</code> or <code>attrib(factor, "contrasts") !=
 "contr.sum"</code>. Furthermore, the current contrasts (obtained via
<code>getOption("contrasts")</code>) will be set at the cluster nodes if <code>cl</code>
is not <code>NULL</code>. </p>



<h4>Expand Random Effects</h4>

 <p><code>expand_re = TRUE</code> allows to expand
the random effects structure before passing it to <code>lmer</code>. This allows
to disable estimation of correlation among random effects for random effects
term containing factors using the <code>||</code> notation which may aid in
achieving model convergence (see Bates et al., 2015). This is achieved by
first creating a model matrix for each random effects term individually,
rename and append the so created columns to the data that will be fitted,
replace the actual random effects term with the so created variables
(concatenated with +), and then fit the model. The variables are renamed by
prepending all variables with rei (where i is the number of the random
effects term) and replacing &quot;:&quot; with &quot;_by_&quot;.
</p>
<p><code>lmer_alt</code> is simply a wrapper for <code>mixed</code> that is intended to
behave like <code>lmer</code> (or <code>glmer</code> if a <code>family</code> argument is
present), but also allows the use of <code>||</code> with factors (by always using
<code>expand_re = TRUE</code>). This means that <code>lmer_alt</code> per default does
not enforce a specific contrast on factors and only returns the
<code>"lmerModLmerTest"</code> or <code>"merMod"</code> object without calculating any
additional models or p-values (this is achieved by setting <code>return =
 "merMod"</code>). Note that it most likely differs from <code>g/lmer</code> in how it
handles missing values so it is recommended to only pass data without
missing values to it!
</p>
<p>One consequence of using <code>expand_re = TRUE</code> is that the data that is
fitted will not be the same as the passed data.frame which can lead to
problems with e.g., the <code>predict</code> method. However, the actual data used
for fitting is also returned as part of the <code>mixed</code> object so can be
used from there. Note that the <code>set_data_arg</code> can be used to change
whether the <code>data</code> argument in the call to <code>g/lmer</code> is set to
<code>data</code> (the default) or the name of the data argument passed by the
user. </p>



<h3>Value</h3>

<p>An object of class <code>"mixed"</code> (i.e., a list) with the following
elements:
</p>

<ol>
<li> <p><code>anova_table</code> a data.frame containing the statistics returned
from <code><a href="../../pbkrtest/html/KRmodcomp.html">KRmodcomp</a></code>. The <code>stat</code> column in this
data.frame gives the value of the test statistic, an F-value for
<code>method = "KR"</code> and a chi-square value for the other two methods.
</p>
</li>
<li> <p><code>full_model</code> the <code>"lmerModLmerTest"</code> or <code>"merMod"</code>
object returned from estimating the full model. Use
<code><a href="afex_options.html">afex_options</a></code><code>("lmer_function")</code> for setting which
function for estimation should be used. The possible options are
<code>"lmerTest"</code> (the default returning an object of class
<code>"lmerModLmerTest"</code>) and <code>"lme4"</code> returning an object of class
(<code>"merMod"</code>). Note that in case a <code>family</code> argument is present
an object of class <code>"glmerMod"</code> is always returned.
</p>
</li>
<li> <p><code>restricted_models</code> a list of <code>"g/lmerMod"</code> (or 
<code>"lmerModLmerTest"</code>) objects from estimating the restricted models
(i.e., each model lacks the corresponding effect)
</p>
</li>
<li> <p><code>tests</code> a list of objects returned by the function for 
obtaining the p-values.
</p>
</li>
<li> <p><code>data</code> The data used for estimation (i.e., after excluding 
missing rows and applying expand_re if requested).
</p>
</li>
<li> <p><code>call</code> The matched call.
</p>
</li></ol>

<p>It also has the following attributes, <code>"type"</code> and <code>"method"</code>. And
the attributes <code>"all_fit_selected"</code> and <code>"all_fit_logLik"</code> if
<code>all_fit=TRUE</code>.
</p>
<p>Two similar methods exist for objects of class <code>"mixed"</code>: <code>print</code>
and <code>anova</code>. They print a nice version of the <code>anova_table</code> element
of the returned object (which is also invisibly returned). This methods omit
some columns and nicely round the other columns. The following columns are
always printed:
</p>

<ol>
<li> <p><code>Effect</code> name of effect
</p>
</li>
<li> <p><code>p.value</code> estimated p-value for the effect
</p>
</li></ol>

<p>For LMMs with <code>method="KR"</code> or <code>method="S"</code> the following further
columns are returned (note: the Kenward-Roger correction does two separate
things: (1) it computes an effective number for the denominator df; (2) it
scales the statistic by a calculated amount, see also
<a href="http://stackoverflow.com/a/25612960/289572">http://stackoverflow.com/a/25612960/289572</a>):
</p>

<ol>
<li> <p><code>F</code> computed F statistic
</p>
</li>
<li> <p><code>ndf</code> numerator degrees of freedom (number of parameters used
for the effect)
</p>
</li>
<li> <p><code>ddf</code> denominator degrees of freedom (effective residual 
degrees of freedom for testing the effect), computed from the
Kenward-Roger correction using <code>pbkrtest::KRmodcomp</code>
</p>
</li>
<li> <p><code>F.scaling</code> scaling of F-statistic computing from Kenward-Roger 
approximation (only printed if <code>method="nested-KR"</code>)
</p>
</li></ol>

<p>For models with <code>method="LRT"</code> the following further columns are
returned:
</p>

<ol>
<li> <p><code>df.large</code> degrees of freedom (i.e., estimated paramaters) for 
full model (i.e., model containing the corresponding effect)
</p>
</li>
<li> <p><code>df.small</code> degrees of freedom (i.e., estimated paramaters) for 
restricted model (i.e., model without the corresponding effect)
</p>
</li>
<li> <p><code>chisq</code> 2 times the difference in likelihood (obtained with 
<code>logLik</code>) between full and restricted model
</p>
</li>
<li> <p><code>df</code> difference in degrees of freedom between full and 
restricted model (p-value is based on these df).
</p>
</li></ol>

<p>For models with <code>method="PB"</code> the following further column is returned:
</p>

<ol>
<li> <p><code>stat</code> 2 times the difference in likelihood (obtained with 
<code>logLik</code>) between full and restricted model (i.e., a chi-square
value).
</p>
</li></ol>

<p>Note that  <code>anova</code> can also be called with additional mixed and/or
<code>merMod</code> objects. In this casethe full models are passed on to
<code>anova.merMod</code> (with <code>refit=FALSE</code>, which differs from the default
of <code>anova.merMod</code>) which produces the known LRT tables.
</p>
<p>The <code>summary</code> method for objects of class <code>mixed</code> simply calls
<code><a href="../../lme4/html/merMod-class.html">summary.merMod</a></code> on the full model.
</p>
<p>If <code>return = "merMod"</code> (or when invoking <code>lmer_alt</code>), an object of
class <code>"lmerModLmerTest"</code> or of class <code>"merMod"</code> (depending on the
value of <code><a href="afex_options.html">afex_options</a></code><code>("lmer_function")</code>), as returned
from <code>g/lmer</code>, is returned. The default behavior is to return an object
of class <code>"lmerModLmerTest"</code> estimated via <code><a href="../../lmerTest/html/lmer.html">lmer</a></code>.
</p>


<h3>Note</h3>

<p>When <code>method = "KR"</code>, obtaining p-values is known to crash due too
insufficient memory or other computational limitations (especially with
complex random effects structures). In these cases, the other methods
should be used. The RAM demand is a problem especially on 32 bit Windows
which only supports up to 2 or 3GB RAM (see
<a href="https://CRAN.R-project.org/bin/windows/base/rw-FAQ.html">R Windows
FAQ</a>). Then it is probably a good idea to use methods &quot;S&quot;, &quot;LRT&quot;, or &quot;PB&quot;.
</p>
<p><code>"mixed"</code> will throw a message if numerical variables are not centered
on 0, as main effects (of other variables then the numeric one) can be hard
to interpret if numerical variables appear in interactions. See Dalal &amp;
Zickar (2012).
</p>
<p>Per default <code>mixed</code> uses <code><a href="../../lmerTest/html/lmer.html">lmer</a></code>, this can be
changed to <code><a href="../../lme4/html/lmer.html">lmer</a></code> by calling:
<code>afex_options(lmer_function = "lme4")</code>
</p>
<p>Formulas longer than 500 characters will most likely fail due to the use of
<code><a href="../../base/html/deparse.html">deparse</a></code>.
</p>
<p>Please report bugs or unexpected behavior by opening a guthub issue:
<a href="https://github.com/singmann/afex/issues">https://github.com/singmann/afex/issues</a>
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann with contributions from
<a href="http://stackoverflow.com/q/11335923/289572">Ben Bolker and Joshua
Wiley</a>.
</p>


<h3>References</h3>

<p>Baayen, R. H. (2008). <em>Analyzing linguistic data: a
practical introduction to statistics using R</em>. Cambridge, UK; New York:
Cambridge University Press.
</p>
<p>Baayen, R. H., Davidson, D. J., &amp; Bates, D. M. (2008). Mixed-effects
modeling with crossed random effects for subjects and items. <em>Journal
of Memory and Language</em>, 59(4), 390-412. doi:10.1016/j.jml.2007.12.005
</p>
<p>Baayen, R. H., &amp; Milin, P. (2010). Analyzing Reaction Times.
<em>International Journal of Psychological Research</em>, 3(2), 12-28.
</p>
<p>Barr, D. J. (2013). Random effects structure for testing interactions in
linear mixed-effects models. <em>Frontiers in Quantitative Psychology and
Measurement</em>, 328. doi:10.3389/fpsyg.2013.00328
</p>
<p>Barr, D. J., Levy, R., Scheepers, C., &amp; Tily, H. J. (2013). Random effects
structure for confirmatory hypothesis testing: Keep it maximal.
<em>Journal of Memory and Language</em>, 68(3), 255-278.
doi:10.1016/j.jml.2012.11.001
</p>
<p>Bates, D., Kliegl, R., Vasishth, S., &amp; Baayen, H. (2015).
<em>Parsimonious Mixed Models</em>. arXiv:1506.04967 [stat]. Retrieved from
<a href="http://arxiv.org/abs/1506.04967">http://arxiv.org/abs/1506.04967</a>
</p>
<p>Dalal, D. K., &amp; Zickar, M. J. (2012). Some Common Myths About Centering
Predictor Variables in Moderated Multiple Regression and Polynomial
Regression. <em>Organizational Research Methods</em>, 15(3), 339-362.
doi:10.1177/1094428111430540
</p>
<p>Judd, C. M., Westfall, J., &amp; Kenny, D. A. (2012). Treating stimuli as a
random factor in social psychology: A new and comprehensive solution to a
pervasive but largely ignored problem. <em>Journal of Personality and
Social Psychology</em>, 103(1), 54-69. doi:10.1037/a0028347
</p>
<p>Luke, S. (2017). Evaluating significance in linear mixed-effects models in
R. <em>Behavior Research Methods</em>.
<a href="https://doi.org/10.3758/s13428-016-0809-y">https://doi.org/10.3758/s13428-016-0809-y</a>
</p>
<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). <em>Designing experiments and
analyzing data: a model-comparisons perspective.</em> Mahwah, N.J.: Lawrence
Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="aov_car.html">aov_ez</a></code> and <code><a href="aov_car.html">aov_car</a></code> for convenience
functions to analyze experimental deisgns with classical ANOVA or ANCOVA
wrapping <code><a href="../../car/html/Anova.html">Anova</a></code>.
</p>
<p>see the following for the data sets from Maxwell and Delaney (2004) used
and more examples: <code><a href="md_15.1.html">md_15.1</a></code>, <code><a href="md_16.1.html">md_16.1</a></code>, and
<code><a href="md_16.4.html">md_16.4</a></code>.
</p>


<h3>Examples</h3>

<pre>

##################################
## Simple Examples (from MEMSS) ##
##################################

data("Machines", package = "MEMSS") 

# simple model with random-slopes for repeated-measures factor
m1 &lt;- mixed(score ~ Machine + (Machine|Worker), data=Machines)
m1

# suppress correlations among random effect parameters with || and expand_re = TRUE
m2 &lt;- mixed(score ~ Machine + (Machine||Worker), data=Machines, expand_re = TRUE)
m2

## compare:
summary(m1)$varcor
summary(m2)$varcor
# for wrong solution see: 
# summary(lmer(score ~ Machine + (Machine||Worker), data=Machines))$varcor

if (requireNamespace("emmeans")) {
# follow-up tests
library("emmeans")  # package emmeans needs to be attached for follow-up tests.
(emm1 &lt;- emmeans(m1, "Machine"))
pairs(emm1, adjust = "holm") # all pairwise comparisons
con1 &lt;- list(
  c1 = c(1, -0.5, -0.5), # 1 versus other 2
  c2 = c(0.5, -1, 0.5) # 1 and 3 versus  2
)
contrast(emm1, con1, adjust = "holm")

if (requireNamespace("ggplot2")) {
# plotting 
afex_plot(m1, "Machine") ## default uses model-based CIs
## within-subjects CIs somewhat more in line with pairwirse comparisons:
afex_plot(m1, "Machine", error = "within") 

## less differences between CIs for model without correlations:
afex_plot(m2, "Machine")
afex_plot(m2, "Machine", error = "within")
}}

## Not run: 
#######################
### Further Options ###
#######################

## Multicore:

require(parallel)
(nc &lt;- detectCores()) # number of cores
cl &lt;- makeCluster(rep("localhost", nc)) # make cluster
# to keep track of what the function is doindg redirect output to outfile:
# cl &lt;- makeCluster(rep("localhost", nc), outfile = "cl.log.txt")

data("Machines", package = "MEMSS") 
## There are two ways to use multicore:

# 1. Obtain fits with multicore:
mixed(score ~ Machine + (Machine|Worker), data=Machines, cl = cl)

# 2. Obtain PB samples via multicore: 
mixed(score ~ Machine + (Machine|Worker), data=Machines,
 method = "PB", args_test = list(nsim = 50, cl = cl)) # better use 500 or 1000 

## Both ways can be combined:
# 2. Obtain PB samples via multicore: 
mixed(score ~ Machine + (Machine|Worker), data=Machines, cl = cl,
 method = "PB", args_test = list(nsim = 50, cl = cl))

#### use all_fit = TRUE and expand_re = TRUE:
data("sk2011.2") # data described in more detail below
sk2_aff &lt;- droplevels(sk2011.2[sk2011.2$what == "affirmation",])

require(optimx) # uses two more algorithms
sk2_aff_b &lt;- mixed(response ~ instruction*type+(inference*type||id), sk2_aff,
               expand_re = TRUE, all_fit = TRUE)
attr(sk2_aff_b, "all_fit_selected")
attr(sk2_aff_b, "all_fit_logLik")

# considerably faster with multicore:
clusterEvalQ(cl, library(optimx)) # need to load optimx in cluster
sk2_aff_b2 &lt;- mixed(response ~ instruction*type+(inference*type||id), sk2_aff,
               expand_re = TRUE, all_fit = TRUE, cl=cl)
attr(sk2_aff_b2, "all_fit_selected")
attr(sk2_aff_b2, "all_fit_logLik")


stopCluster(cl)


## End(Not run)

###################################################
## Replicating Maxwell &amp; Delaney (2004) Examples ##
###################################################
## Not run: 

### replicate results from Table 15.4 (Maxwell &amp; Delaney, 2004, p. 789)
data(md_15.1)
# random intercept plus random slope
(t15.4a &lt;- mixed(iq ~ timecat + (1+time|id),data=md_15.1))

# to also replicate exact parameters use treatment.contrasts and the last level as base level:
contrasts(md_15.1$timecat) &lt;- contr.treatment(4, base = 4)
(t15.4b &lt;- mixed(iq ~ timecat + (1+time|id),data=md_15.1, check_contrasts=FALSE))
summary(t15.4a)  # gives "wrong" parameters extimates
summary(t15.4b)  # identical parameters estimates

# for more examples from chapter 15 see ?md_15.1

### replicate results from Table 16.3 (Maxwell &amp; Delaney, 2004, p. 837)
data(md_16.1)

# original results need treatment contrasts:
(mixed1_orig &lt;- mixed(severity ~ sex + (1|id), md_16.1, check_contrasts=FALSE))
summary(mixed1_orig$full_model)

# p-value stays the same with afex default contrasts (contr.sum),
# but estimates and t-values for the fixed effects parameters change.
(mixed1 &lt;- mixed(severity ~ sex + (1|id), md_16.1))
summary(mixed1$full_model)


# data for next examples (Maxwell &amp; Delaney, Table 16.4)
data(md_16.4)
str(md_16.4)

### replicate results from Table 16.6 (Maxwell &amp; Delaney, 2004, p. 845)
# Note that (1|room:cond) is needed because room is nested within cond.
# p-value (almost) holds.
(mixed2 &lt;- mixed(induct ~ cond + (1|room:cond), md_16.4))
# (differences are dut to the use of Kenward-Roger approximation here,
# whereas M&amp;W's p-values are based on uncorrected df.)

# again, to obtain identical parameter and t-values, use treatment contrasts:
summary(mixed2) # not identical

# prepare new data.frame with contrasts:
md_16.4b &lt;- within(md_16.4, cond &lt;- C(cond, contr.treatment, base = 2))
str(md_16.4b)

# p-value stays identical:
(mixed2_orig &lt;- mixed(induct ~ cond + (1|room:cond), md_16.4b, check_contrasts=FALSE))
summary(mixed2_orig$full_model) # replicates parameters


### replicate results from Table 16.7 (Maxwell &amp; Delaney, 2004, p. 851)
# F-values (almost) hold, p-values (especially for skill) are off
(mixed3 &lt;- mixed(induct ~ cond + skill + (1|room:cond), md_16.4))

# however, parameters are perfectly recovered when using the original contrasts:
mixed3_orig &lt;- mixed(induct ~ cond + skill + (1|room:cond), md_16.4b, check_contrasts=FALSE)
summary(mixed3_orig)


### replicate results from Table 16.10 (Maxwell &amp; Delaney, 2004, p. 862)
# for this we need to center cog:
md_16.4b$cog &lt;- scale(md_16.4b$cog, scale=FALSE)

# F-values and p-values are relatively off:
(mixed4 &lt;- mixed(induct ~ cond*cog + (cog|room:cond), md_16.4b))
# contrast has a relatively important influence on cog
(mixed4_orig &lt;- mixed(induct ~ cond*cog + (cog|room:cond), md_16.4b, check_contrasts=FALSE))

# parameters are again almost perfectly recovered:
summary(mixed4_orig)

## End(Not run)

###########################
## Full Analysis Example ##
###########################

## Not run: 
### split-plot experiment (Singmann &amp; Klauer, 2011, Exp. 2)
## between-factor: instruction
## within-factor: inference &amp; type
## hypothesis: three-way interaction
data("sk2011.2")

# use only affirmation problems (S&amp;K also splitted the data like this)
sk2_aff &lt;- droplevels(sk2011.2[sk2011.2$what == "affirmation",])

# set up model with maximal by-participant random slopes 
sk_m1 &lt;- mixed(response ~ instruction*inference*type+(inference*type|id), sk2_aff)

sk_m1 # prints ANOVA table with nicely rounded numbers (i.e., as characters)
nice(sk_m1)  # returns the same but without printing potential warnings
anova(sk_m1) # returns and prints numeric ANOVA table (i.e., not-rounded)
summary(sk_m1) # lmer summary of full model

# same model but using Satterthwaite approximation of df
# very similar results but faster
sk_m1b &lt;- mixed(response ~ instruction*inference*type+(inference*type|id), 
                sk2_aff, method="S")
nice(sk_m1b)
# identical results as:
anova(sk_m1$full_model)

# suppressing correlation among random slopes:
# very similar results, but significantly faster and often less convergence warnings. 
sk_m2 &lt;- mixed(response ~ instruction*inference*type+(inference*type||id), sk2_aff,
               expand_re = TRUE)
sk_m2

## mixed objects can be passed to emmeans
library("emmeans")  # however, package emmeans needs to be attached first

# emmeans also approximate df which takes time with default Kenward-Roger
emm_options(lmer.df = "Kenward-Roger") # default setting, slow
emm_options(lmer.df = "Satterthwaite") # faster setting, preferrable
emm_options(lmer.df = "asymptotic") # the fastest, df = infinity


# recreates basically Figure 4 (S&amp;K, 2011, upper panel)
# only the 4th and 6th x-axis position are flipped
afex_plot(sk_m1, x = c("type", "inference"), trace = "instruction")

# set up reference grid for custom contrasts:
(rg1 &lt;- emmeans(sk_m1, c("instruction", "type", "inference")))

# set up contrasts on reference grid:
contr_sk2 &lt;- list(
  ded_validity_effect = c(rep(0, 4), 1, rep(0, 5), -1, 0),
  ind_validity_effect = c(rep(0, 5), 1, rep(0, 5), -1),
  counter_MP = c(rep(0, 4), 1, -1, rep(0, 6)),
  counter_AC = c(rep(0, 10), 1, -1)
)

# test the main double dissociation (see S&amp;K, p. 268)
contrast(rg1, contr_sk2, adjust = "holm")
# all effects are significant.

## End(Not run)

####################
## Other Examples ##
####################

## Not run: 

# use the obk.long data (not reasonable, no random slopes)
data(obk.long)
mixed(value ~ treatment * phase + (1|id), obk.long)

# Examples for using the per.parameter argument 
# note, require method = "nested-KR", "LRT", or "PB" 
# also we use custom contrasts
data(obk.long, package = "afex")
obk.long$hour &lt;- ordered(obk.long$hour)
contrasts(obk.long$phase) &lt;- "contr.sum"
contrasts(obk.long$treatment) &lt;- "contr.sum" 

# tests only the main effect parameters of hour individually per parameter.
mixed(value ~ treatment*phase*hour +(1|id), per_parameter = "^hour$", 
      data = obk.long, method = "nested-KR", check_contrasts = FALSE)

# tests all parameters including hour individually
mixed(value ~ treatment*phase*hour +(1|id), per_parameter = "hour", 
      data = obk.long, method = "nested-KR", check_contrasts = FALSE)

# tests all parameters individually
mixed(value ~ treatment*phase*hour +(1|id), per_parameter = ".", 
      data = obk.long, method = "nested-KR", check_contrasts = FALSE)

# example data from package languageR:
# Lexical decision latencies elicited from 21 subjects for 79 English concrete nouns, 
# with variables linked to subject or word. 
data(lexdec, package = "languageR")

# using the simplest model
m1 &lt;- mixed(RT ~ Correct + Trial + PrevType * meanWeight + 
    Frequency + NativeLanguage * Length + (1|Subject) + (1|Word), data = lexdec)
m1
# Mixed Model Anova Table (Type 3 tests, KR-method)
# 
# Model: RT ~ Correct + Trial + PrevType * meanWeight + Frequency + NativeLanguage * 
# Model:     Length + (1 | Subject) + (1 | Word)
# Data: lexdec
#                  Effect         df         F p.value
# 1               Correct 1, 1627.73   8.15 **    .004
# 2                 Trial 1, 1592.43   7.57 **    .006
# 3              PrevType 1, 1605.39      0.17     .68
# 4            meanWeight   1, 75.39 14.85 ***   .0002
# 5             Frequency   1, 76.08 56.53 ***  &lt;.0001
# 6        NativeLanguage   1, 27.11      0.70     .41
# 7                Length   1, 75.83   8.70 **    .004
# 8   PrevType:meanWeight 1, 1601.18    6.18 *     .01
# 9 NativeLanguage:Length 1, 1555.49 14.24 ***   .0002
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1

# Fitting a GLMM using parametric bootstrap:
require("mlmRev") # for the data, see ?Contraception

gm1 &lt;- mixed(use ~ age + I(age^2) + urban + livch + (1 | district), method = "PB",
 family = binomial, data = Contraception, args_test = list(nsim = 10))
## note that nsim = 10 is way too low for all real examples!


## End(Not run)

## Not run: 
#####################################
## Interplay with effects packages ##
#####################################

data("Machines", package = "MEMSS") 
# simple model with random-slopes for repeated-measures factor
m1 &lt;- mixed(score ~ Machine + (Machine|Worker), data=Machines, 
            set_data_arg = TRUE) ## necessary for it to work!
  
library("effects")

Effect("Machine", m1$full_model) # not correct:
#  Machine effect
# Machine
#        A        B        C 
# 59.65000 52.35556 60.32222 

# compare:
emmeans::emmeans(m1, "Machine")
 # Machine   emmean       SE  df asymp.LCL asymp.UCL
 # A       52.35556 1.680711 Inf  49.06142  55.64969
 # B       60.32222 3.528546 Inf  53.40640  67.23804
 # C       66.27222 1.806273 Inf  62.73199  69.81245

## necessary to set contr.sum globally:
set_sum_contrasts()
Effect("Machine", m1$full_model)
#  Machine effect
# Machine
#        A        B        C 
# 52.35556 60.32222 66.27222 

plot(Effect("Machine", m1$full_model))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>afex</em> version 0.28 <a href="00Index.html">Index</a>]</div>
</body></html>
